package contest.winter2017;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.lang3.StringUtils;

/**
 * Entry-point class for the black-box testing framework
 * 
 * @author IDT
 */
public class Main {

	/**
	 * cli key for path to the executable black-box jar to test
	 */
	public static final String JAR_TO_TEST_PATH = "jarToTestPath";

	/**
	 * cli key for path to the directory to be used to store output generated by
	 * jacoco framework
	 */
	public static final String JACOCO_OUTPUT_PATH = "jacocoOutputPath";

	/**
	 * cli key for path to the jacoco agent jar used to instrument the
	 * executable black-box jar in order to collect code coverage metrics
	 */
	public static final String JACOCO_AGENT_JAR_PATH = "jacocoAgentJarPath";

	/**
	 * cli key
	 */
	public static final String BB_TESTS = "bbTests";

	/**
	 * cli key for number of minutes to run.
	 */
	public static final String TIME_GOAL = "timeGoal";

	/**
	 * cli key
	 */
	public static final String TOOL_CHAIN = "toolChain";

	/**
	 * cli key for application help
	 */
	public static final String HELP = "help";

	/**
	 * alternative cli key for application help
	 */
	public static final String ALT_HELP = "h";

	public volatile static boolean gui = false;

	/**
	 * Entry-point method for the black-box testing framework
	 * 
	 * @param args
	 *            - String array of command line arguments
	 */
	public static void main(String[] args) {
		StdoutWrapper.init();

		Options options = buildOptions();
		try {
			CommandLine cliArgs = new DefaultParser().parse(options, args);
			if (cliArgs != null) {
				// if we have the three arguments we need for exploratory
				// black-box testing, initialize and execute the tester.
				if (cliArgs.hasOption(JAR_TO_TEST_PATH) && cliArgs.hasOption(JACOCO_OUTPUT_PATH)
						&& cliArgs.hasOption(JACOCO_AGENT_JAR_PATH)) {
					String jarToTestPath = cliArgs.getOptionValue(JAR_TO_TEST_PATH);
					String jacocoOutputDirPath = cliArgs.getOptionValue(JACOCO_OUTPUT_PATH);
					String jacocoAgentJarPath = cliArgs.getOptionValue(JACOCO_AGENT_JAR_PATH);
					Integer bbTests = null;
					Integer timeGoal = null;
					try {
						bbTests = processBbTestOption(cliArgs, options);
						timeGoal = processTimeGoalOption(cliArgs, options);
					} catch (RuntimeException e) {
						return;
					}

					StdoutWrapper.setToolChain(cliArgs.hasOption(TOOL_CHAIN));
					printParams(jacocoAgentJarPath, jacocoOutputDirPath, jarToTestPath, bbTests, timeGoal);

					// the Tester class contains all of the logic for the
					// testing framework
					Tester tester = new Tester();
					if (tester.init(jarToTestPath, jacocoOutputDirPath, jacocoAgentJarPath, bbTests, timeGoal)) {
						// this is the simple testing that we have implemented -
						// likely no need to change
						// this code much
						tester.executeBasicTests();
						// this is the security vulnerability testing that we
						// want you to implement
						tester.executeSecurityTests();
					}

					// if the user has requested help
				} else if (cliArgs.hasOption(HELP) || cliArgs.hasOption(ALT_HELP)) {
					printHelp(options);

					// user did not request help and we had an inadequate number
					// of arguments
				} else {
					StdoutWrapper.println("Failed to execute - application requires at least three parameters.");
					printHelp(options);
				}
			}
		} catch (ParseException exp) {
			StdoutWrapper.println("An error occurred during command line parsing: " + exp.getMessage());
		}
	}

	public static void runMain(String jacocoAgentJarPath, String jacocoOutputPath, String jarToTestPath, String bbTests,
			String timeGoal, boolean toolChain) {
		List<String> argList = new ArrayList<String>();
		if (StringUtils.isNotBlank(jacocoAgentJarPath)) {
			argList.add('-' + JACOCO_AGENT_JAR_PATH);
			argList.add(jacocoAgentJarPath);
		}
		if (StringUtils.isNotBlank(jacocoOutputPath)) {
			argList.add('-' + JACOCO_OUTPUT_PATH);
			argList.add(jacocoOutputPath);
		}
		if (StringUtils.isNotBlank(jarToTestPath)) {
			argList.add('-' + JAR_TO_TEST_PATH);
			argList.add(jarToTestPath);
		}
		if (StringUtils.isNotBlank(bbTests)) {
			argList.add('-' + BB_TESTS);
			argList.add(bbTests);
		}
		if (StringUtils.isNotBlank(timeGoal)) {
			argList.add('-' + TIME_GOAL);
			argList.add(timeGoal);
		}

		if (toolChain) {
			argList.add('-' + TOOL_CHAIN);
		}
		Main.main(argList.toArray(new String[argList.size()]));
	}

	/**
	 * private static method used to print the application help
	 */
	private static void printHelp(Options options) {
		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		String header = "\n";
		String footer = "\nFor additional information about the testing framework, please see the documentation provided by IDT.";

		HelpFormatter formatter = new HelpFormatter();
		formatter.printHelp(pw, formatter.getWidth(), "com.idtus.contest.winter2017.framework", header, options,
				formatter.getLeftPadding(), formatter.getDescPadding(), footer, true);
		StdoutWrapper.printf(sw.toString());
	}

	private static Options buildOptions() {
		Options options = new Options();
		options.addOption(JAR_TO_TEST_PATH, true, "path to the executable jar to test");
		options.addOption(JACOCO_OUTPUT_PATH, true, "path to directory for jacoco output");
		options.addOption(JACOCO_AGENT_JAR_PATH, true, "path to the jacoco agent jar");
		options.addOption(HELP, false, "help");
		options.addOption(ALT_HELP, false, "help");

		Option bbTestsOpt = Option.builder(BB_TESTS).desc("number of exploratory black box tests to run").hasArg()
				.required(false).build();
		options.addOption(bbTestsOpt);

		Option timeGoalOpt = Option.builder(TIME_GOAL).desc("number of minutes to run").hasArg().required(false)
				.build();
		options.addOption(timeGoalOpt);

		Option toolChainOpt = Option.builder(TOOL_CHAIN).desc("limit the output to contain only a YAML report")
				.hasArg(false).required(false).build();
		options.addOption(toolChainOpt);

		return options;
	}

	private static Integer processBbTestOption(CommandLine cliArgs, Options options) {
		String bbTestsStr = cliArgs.getOptionValue(BB_TESTS);
		if (bbTestsStr != null) {
			try {
				return Integer.valueOf(bbTestsStr);
			} catch (NumberFormatException nfEx) {
				StdoutWrapper.println("Failed to execute - bbTests must be an integer.");
				printHelp(options);
				throw nfEx;
			}
		}
		return null;
	}

	private static Integer processTimeGoalOption(CommandLine cliArgs, Options options) {
		String timeGoalStr = cliArgs.getOptionValue(TIME_GOAL);
		Integer timeGoal = null;
		if (timeGoalStr != null) {
			try {
				timeGoal = Integer.valueOf(timeGoalStr);
				if (timeGoal < 0) {
					String errMessage = "Failed to execute - timeGoal must be nonnegative.";
					StdoutWrapper.println(errMessage);
					printHelp(options);
					throw new RuntimeException(errMessage);
				}
			} catch (NumberFormatException nfEx) {
				StdoutWrapper.println("Failed to execute - timeGoal must be an integer.");
				printHelp(options);
				throw nfEx;
			}
		}
		if (timeGoal != null)
			timeGoal *= 60;

		return timeGoal;
	}

	private static void printParams(String jacocoAgentJarPath, String jacocoOutPath, String jarToTestPath,
			Integer bbTests, Integer timeGoal) {
		StdoutWrapper.printf("IDT options: \n");
		StdoutWrapper.printf("  -%s %s\n", JACOCO_AGENT_JAR_PATH, jacocoAgentJarPath);
		StdoutWrapper.printf("  -%s %s\n", JACOCO_OUTPUT_PATH, jacocoOutPath);
		StdoutWrapper.printf("  -%s %s\n", JAR_TO_TEST_PATH, jarToTestPath);
		StdoutWrapper.printf("  -%s %s\n", BB_TESTS, bbTests);
		StdoutWrapper.printf("  -%s %s\n", TIME_GOAL, timeGoal);
		StdoutWrapper.printf("  -%s\n", TOOL_CHAIN);
	}
}
